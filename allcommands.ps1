### DO NOT EDIT THIS FILE DIRECTLY ###

#.ExternalHelp woztools-Help.xml
Function Add-EnvPath {
  <#
      .SYNOPSIS
      Add a Folder to Environment Variable PATH

      .DESCRIPTION
      Add Folders to Environment Variable PATH for Machine, User or Process scope
      And removes missing PATH locations

      .PARAMETER Path
      Folder or Folders to add to PATH

      .PARAMETER VariableTarget
      Which Env Path the directory gets added to.
      Machine, User or Process
	  
      .PARAMETER PassThru
      Display updated PATH variable

      .INPUTS
      [String] - Folder Path, accepts multiple folders

      .OUTPUTS
      String - List of the New Path Variable

      .EXAMPLE
      Add-EnvPath -Path 'C:\temp' -VariableTarget Machine
  #>
  param(
    [Parameter(Mandatory,ValueFromPipeline)]
    [ValidateScript({
          if (-not (Test-Path -Path $_ -PathType Container)) {
            throw 'Path must be a Folder'
          }
          return $true
    })]
    [String[]]$Path,
    [System.EnvironmentVariableTarget]$VariableTarget = [System.EnvironmentVariableTarget]::Machine,
    [switch]$PassThru
  )
  begin {
    if (-not (Test-IfAdmin)) { throw 'RUN AS ADMINISTRATOR' }
    $OldPath = [System.Environment]::GetEnvironmentVariable('PATH',$VariableTarget).Split(';').TrimEnd('\') | Convert-Path -ErrorAction SilentlyContinue
    $NewPath = [System.Collections.ArrayList]::new()
    $NewPath.AddRange($OldPath)
  }
  process{
    foreach($NDir in $Path) {
      $NDir = (Convert-Path -Path $NDir -ErrorAction SilentlyContinue).TrimEnd('\')
      if ($NewPath -notcontains $NDir) { $null = $NewPath.Add($NDir) }
      else {
        Write-Warning -Message ('SKIPPING:{0} - duplicates not included' -f $NDir)
      }
    }
  }
  end {
    [System.Environment]::SetEnvironmentVariable('PATH',(($NewPath | Sort-Object -Unique) -join ';'),$VariableTarget)
    if ($PassThru) {
      $Confirm = [System.Environment]::GetEnvironmentVariable('PATH',$VariableTarget).Split(';')
      return $Confirm
    }
  }
} 
#.ExternalHelp woztools-Help.xml
function Add-Font {
  <#
      .SYNOPSIS
      Add fonts to system

      .DESCRIPTION
      Install a font from file path using CSharp code, compatitable fonts are available for use within the console font list.

      .PARAMETER Path
      Path of Font File, can accept multiple font files
      Supported File Types - .ttc, .ttf, .fnt, .otf, .fon

      .EXAMPLE
      Add-Font -Path C:\temp\mononoki-nerdfont.ttf

      .NOTES
      Administartor privileges are required
  #>
  param(
    [Parameter(Mandatory)]
    [ValidateScript({
          if(-not ($_ | Test-Path -PathType Leaf) ){
            throw 'File does not exist'
          }
          return $true
    })]
    [ValidatePattern('(\.ttc|\.ttf|\.fnt|\.otf|\.fon)$')]
    [string[]]$Path,
    [switch]$Remove
  )
  begin {

    $IsAdmin = ([System.Security.Principal.WindowsPrincipal][System.Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)
    if (-not ($IsAdmin)) {
      throw 'This must run with admin privileges'
    }

    $FontsFolderPath = [System.Environment]::GetFolderPath([System.Environment+SpecialFolder]::Fonts)

    # Define constants
    Set-Variable -Name CSIDL_FONTS -Value 0x14 -Option Constant -Force

    # Create hashtable containing valid font file extensions and text to append to Registry entry name.
    $HashFontFileTypes = @{}
    $HashFontFileTypes.Add('.fon', '')
    $HashFontFileTypes.Add('.fnt', '')
    $HashFontFileTypes.Add('.ttf', ' (TrueType)')
    $HashFontFileTypes.Add('.ttc', ' (TrueType)')
    $HashFontFileTypes.Add('.otf', ' (OpenType)')

    $FontCSharpCode = @'
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Runtime.InteropServices;

namespace FontResource
{
    public class AddRemoveFonts
    {
        private static IntPtr HWND_BROADCAST = new IntPtr(0xffff);
        private static IntPtr HWND_TOP = new IntPtr(0);
        private static IntPtr HWND_BOTTOM = new IntPtr(1);
        private static IntPtr HWND_TOPMOST = new IntPtr(-1);
        private static IntPtr HWND_NOTOPMOST = new IntPtr(-2);
        private static IntPtr HWND_MESSAGE = new IntPtr(-3);

        [DllImport("gdi32.dll")]
        static extern int AddFontResource(string lpFilename);

        [DllImport("gdi32.dll")]
        static extern int RemoveFontResource(string lpFileName);

        [DllImport("user32.dll",CharSet=CharSet.Auto)]
        private static extern int SendMessage(IntPtr hWnd, WM wMsg, IntPtr wParam, IntPtr lParam);

        [return: MarshalAs(UnmanagedType.Bool)]
        [DllImport("user32.dll", SetLastError = true)]
        private static extern bool PostMessage(IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam);

        public static int AddFont(string fontFilePath) {
            FileInfo fontFile = new FileInfo(fontFilePath);
            if (!fontFile.Exists)
            {
                return 0;
            }
            try
            {
                int retVal = AddFontResource(fontFilePath);

                bool posted = PostMessage(HWND_BROADCAST, WM.FONTCHANGE, IntPtr.Zero, IntPtr.Zero);

                return retVal;
            }
            catch
            {
                return 0;
            }
        }

        public static int RemoveFont(string fontFileName) {
            try
            {
                int retVal = RemoveFontResource(fontFileName);

                bool posted = PostMessage(HWND_BROADCAST, WM.FONTCHANGE, IntPtr.Zero, IntPtr.Zero);

                return retVal;
            }
            catch
            {
                return 0;
            }
        }

        public enum WM : uint
        {
            NULL = 0x0000,
            CREATE = 0x0001,
            DESTROY = 0x0002,
            MOVE = 0x0003,
            SIZE = 0x0005,
            ACTIVATE = 0x0006,
            SETFOCUS = 0x0007,
            KILLFOCUS = 0x0008,
            ENABLE = 0x000A,
            SETREDRAW = 0x000B,
            SETTEXT = 0x000C,
            GETTEXT = 0x000D,
            GETTEXTLENGTH = 0x000E,
            PAINT = 0x000F,
            CLOSE = 0x0010,
            QUERYENDSESSION = 0x0011,
            QUERYOPEN = 0x0013,
            ENDSESSION = 0x0016,
            QUIT = 0x0012,
            ERASEBKGND = 0x0014,
            SYSCOLORCHANGE = 0x0015,
            SHOWWINDOW = 0x0018,
            WININICHANGE = 0x001A,
            SETTINGCHANGE = WM.WININICHANGE,
            DEVMODECHANGE = 0x001B,
            ACTIVATEAPP = 0x001C,
            FONTCHANGE = 0x001D,
            TIMECHANGE = 0x001E,
            CANCELMODE = 0x001F,
            SETCURSOR = 0x0020,
            MOUSEACTIVATE = 0x0021,
            CHILDACTIVATE = 0x0022,
            QUEUESYNC = 0x0023,
            GETMINMAXINFO = 0x0024,
            PAINTICON = 0x0026,
            ICONERASEBKGND = 0x0027,
            NEXTDLGCTL = 0x0028,
            SPOOLERSTATUS = 0x002A,
            DRAWITEM = 0x002B,
            MEASUREITEM = 0x002C,
            DELETEITEM = 0x002D,
            VKEYTOITEM = 0x002E,
            CHARTOITEM = 0x002F,
            SETFONT = 0x0030,
            GETFONT = 0x0031,
            SETHOTKEY = 0x0032,
            GETHOTKEY = 0x0033,
            QUERYDRAGICON = 0x0037,
            COMPAREITEM = 0x0039,
            GETOBJECT = 0x003D,
            COMPACTING = 0x0041,
            COMMNOTIFY = 0x0044,
            WINDOWPOSCHANGING = 0x0046,
            WINDOWPOSCHANGED = 0x0047,
            POWER = 0x0048,
            COPYDATA = 0x004A,
            CANCELJOURNAL = 0x004B,
            NOTIFY = 0x004E,
            INPUTLANGCHANGEREQUEST = 0x0050,
            INPUTLANGCHANGE = 0x0051,
            TCARD = 0x0052,
            HELP = 0x0053,
            USERCHANGED = 0x0054,
            NOTIFYFORMAT = 0x0055,
            CONTEXTMENU = 0x007B,
            STYLECHANGING = 0x007C,
            STYLECHANGED = 0x007D,
            DISPLAYCHANGE = 0x007E,
            GETICON = 0x007F,
            SETICON = 0x0080,
            NCCREATE = 0x0081,
            NCDESTROY = 0x0082,
            NCCALCSIZE = 0x0083,
            NCHITTEST = 0x0084,
            NCPAINT = 0x0085,
            NCACTIVATE = 0x0086,
            GETDLGCODE = 0x0087,
            SYNCPAINT = 0x0088,
            NCMOUSEMOVE = 0x00A0,
            NCLBUTTONDOWN = 0x00A1,
            NCLBUTTONUP = 0x00A2,
            NCLBUTTONDBLCLK = 0x00A3,
            NCRBUTTONDOWN = 0x00A4,
            NCRBUTTONUP = 0x00A5,
            NCRBUTTONDBLCLK = 0x00A6,
            NCMBUTTONDOWN = 0x00A7,
            NCMBUTTONUP = 0x00A8,
            NCMBUTTONDBLCLK = 0x00A9,
            NCXBUTTONDOWN = 0x00AB,
            NCXBUTTONUP = 0x00AC,
            NCXBUTTONDBLCLK = 0x00AD,
            INPUT_DEVICE_CHANGE = 0x00FE,
            INPUT = 0x00FF,
            KEYFIRST = 0x0100,
            KEYDOWN = 0x0100,
            KEYUP = 0x0101,
            CHAR = 0x0102,
            DEADCHAR = 0x0103,
            SYSKEYDOWN = 0x0104,
            SYSKEYUP = 0x0105,
            SYSCHAR = 0x0106,
            SYSDEADCHAR = 0x0107,
            UNICHAR = 0x0109,
            KEYLAST = 0x0109,
            IME_STARTCOMPOSITION = 0x010D,
            IME_ENDCOMPOSITION = 0x010E,
            IME_COMPOSITION = 0x010F,
            IME_KEYLAST = 0x010F,
            INITDIALOG = 0x0110,
            COMMAND = 0x0111,
            SYSCOMMAND = 0x0112,
            TIMER = 0x0113,
            HSCROLL = 0x0114,
            VSCROLL = 0x0115,
            INITMENU = 0x0116,
            INITMENUPOPUP = 0x0117,
            MENUSELECT = 0x011F,
            MENUCHAR = 0x0120,
            ENTERIDLE = 0x0121,
            MENURBUTTONUP = 0x0122,
            MENUDRAG = 0x0123,
            MENUGETOBJECT = 0x0124,
            UNINITMENUPOPUP = 0x0125,
            MENUCOMMAND = 0x0126,
            CHANGEUISTATE = 0x0127,
            UPDATEUISTATE = 0x0128,
            QUERYUISTATE = 0x0129,
            CTLCOLORMSGBOX = 0x0132,
            CTLCOLOREDIT = 0x0133,
            CTLCOLORLISTBOX = 0x0134,
            CTLCOLORBTN = 0x0135,
            CTLCOLORDLG = 0x0136,
            CTLCOLORSCROLLBAR = 0x0137,
            CTLCOLORSTATIC = 0x0138,
            MOUSEFIRST = 0x0200,
            MOUSEMOVE = 0x0200,
            LBUTTONDOWN = 0x0201,
            LBUTTONUP = 0x0202,
            LBUTTONDBLCLK = 0x0203,
            RBUTTONDOWN = 0x0204,
            RBUTTONUP = 0x0205,
            RBUTTONDBLCLK = 0x0206,
            MBUTTONDOWN = 0x0207,
            MBUTTONUP = 0x0208,
            MBUTTONDBLCLK = 0x0209,
            MOUSEWHEEL = 0x020A,
            XBUTTONDOWN = 0x020B,
            XBUTTONUP = 0x020C,
            XBUTTONDBLCLK = 0x020D,
            MOUSEHWHEEL = 0x020E,
            MOUSELAST = 0x020E,
            PARENTNOTIFY = 0x0210,
            ENTERMENULOOP = 0x0211,
            EXITMENULOOP = 0x0212,
            NEXTMENU = 0x0213,
            SIZING = 0x0214,
            CAPTURECHANGED = 0x0215,
            MOVING = 0x0216,
            POWERBROADCAST = 0x0218,
            DEVICECHANGE = 0x0219,
            MDICREATE = 0x0220,
            MDIDESTROY = 0x0221,
            MDIACTIVATE = 0x0222,
            MDIRESTORE = 0x0223,
            MDINEXT = 0x0224,
            MDIMAXIMIZE = 0x0225,
            MDITILE = 0x0226,
            MDICASCADE = 0x0227,
            MDIICONARRANGE = 0x0228,
            MDIGETACTIVE = 0x0229,
            MDISETMENU = 0x0230,
            ENTERSIZEMOVE = 0x0231,
            EXITSIZEMOVE = 0x0232,
            DROPFILES = 0x0233,
            MDIREFRESHMENU = 0x0234,
            IME_SETCONTEXT = 0x0281,
            IME_NOTIFY = 0x0282,
            IME_CONTROL = 0x0283,
            IME_COMPOSITIONFULL = 0x0284,
            IME_SELECT = 0x0285,
            IME_CHAR = 0x0286,
            IME_REQUEST = 0x0288,
            IME_KEYDOWN = 0x0290,
            IME_KEYUP = 0x0291,
            MOUSEHOVER = 0x02A1,
            MOUSELEAVE = 0x02A3,
            NCMOUSEHOVER = 0x02A0,
            NCMOUSELEAVE = 0x02A2,
            WTSSESSION_CHANGE = 0x02B1,
            TABLET_FIRST = 0x02c0,
            TABLET_LAST = 0x02df,
            CUT = 0x0300,
            COPY = 0x0301,
            PASTE = 0x0302,
            CLEAR = 0x0303,
            UNDO = 0x0304,
            RENDERFORMAT = 0x0305,
            RENDERALLFORMATS = 0x0306,
            DESTROYCLIPBOARD = 0x0307,
            DRAWCLIPBOARD = 0x0308,
            PAINTCLIPBOARD = 0x0309,
            VSCROLLCLIPBOARD = 0x030A,
            SIZECLIPBOARD = 0x030B,
            ASKCBFORMATNAME = 0x030C,
            CHANGECBCHAIN = 0x030D,
            HSCROLLCLIPBOARD = 0x030E,
            QUERYNEWPALETTE = 0x030F,
            PALETTEISCHANGING = 0x0310,
            PALETTECHANGED = 0x0311,
            HOTKEY = 0x0312,
            PRINT = 0x0317,
            PRINTCLIENT = 0x0318,
            APPCOMMAND = 0x0319,
            THEMECHANGED = 0x031A,
            CLIPBOARDUPDATE = 0x031D,
            DWMCOMPOSITIONCHANGED = 0x031E,
            DWMNCRENDERINGCHANGED = 0x031F,
            DWMCOLORIZATIONCOLORCHANGED = 0x0320,
            DWMWINDOWMAXIMIZEDCHANGE = 0x0321,
            GETTITLEBARINFOEX = 0x033F,
            HANDHELDFIRST = 0x0358,
            HANDHELDLAST = 0x035F,
            AFXFIRST = 0x0360,
            AFXLAST = 0x037F,
            PENWINFIRST = 0x0380,
            PENWINLAST = 0x038F,
            APP = 0x8000,
            USER = 0x0400,
            CPL_LAUNCH = USER+0x1000,
            CPL_LAUNCHED = USER+0x1001,
            SYSTIMER = 0x118
        }
    }
}
'@
    $AddFontCode = Add-Type -TypeDefinition $FontCSharpCode -PassThru

  }
  process {
    foreach($FilePath in $Path) {

      $FileInfo = [System.IO.FileInfo]::new($FilePath)

      if ($Remove) {
        $RetVal = [FontResource.AddRemoveFonts]::RemoveFont($FilePath.FullName)
        if ($RetVal -eq 0) {
          throw ('Failed to remove font - "{0}"' -f ($FileInfo.FullName))
        }
        else {
          $RegFonts = Get-Item -Path 'registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts\'
          $RFData = $RegFonts.GetValueNames() | ForEach-Object {
            try {
              [pscustomobject]@{
                Font = $_
                Path = (Join-Path -Path 'C:\Windows\Fonts\' -ChildPath $rf.GetValue($_) -Resolve -ErrorAction Stop)
              }
            }
            catch {}
          }

          $RFItem = $RFData | Where-Object {$_.Path -eq $FileInfo.FullName}
          $RFItem | Write-Verbose -Verbose
          Remove-ItemProperty -Path 'registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts\' -Name $RFItem.Font -Force -Verbose
          Get-Item -Path $RFItem.Path | Remove-Item -Force -Verbose
        }
      }
      else {
        try {

          $Shell = New-Object -ComObject Shell.Application
          $MyFolder = $Shell.Namespace($FileInfo.DirectoryName)
          $FileObj = $MyFolder.Items().Item($FileInfo.Name)
          $FontName = $MyFolder.GetDetailsOf($FileObj,21)
          if ($FontName -eq '') { $FontName = $FileInfo.BaseName }

          $FontFinalPath = Copy-Item -Path $FileInfo.FullName -Destination $FontsFolderPath -PassThru -Force -ErrorAction Stop
          $RetVal = [FontResource.AddRemoveFonts]::AddFont($FontFinalPath.FullName)

          if ($RetVal -eq 0) {
            throw ('Failed to install font - "{0}"' -f ($FileInfo.FullName))
          }
          else {
            $SetItemProp = @{
              Path = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts'
              Name = '{0}{1}' -f $FontName, $HashFontFileTypes.Item($FileInfo.Extension)
              Value = $FileInfo.Name
              Type = 'String'
              Force = $true
              ErrorAction = 'Stop'
            }
            $null = Set-ItemProperty @SetItemProp
            Write-Host ('Font install successful - "{0}"' -f ($FileInfo.FullName)) -ForegroundColor Green
            Write-Host ''
          }
        }
        catch {
          Write-Host ''
          [System.Management.Automation.ErrorRecord]$e = $_
          [PSCustomObject]@{
            Type      = $e.Exception.GetType().FullName
            Exception = $e.Exception.Message
            Reason    = $e.CategoryInfo.Reason
            Target    = $e.CategoryInfo.TargetName
            Script    = $e.InvocationInfo.ScriptName
            Line      = $e.InvocationInfo.ScriptLineNumber
            Column    = $e.InvocationInfo.OffsetInLine
          }
          Write-Host ''
          throw ('An error occured installing - "{0}"' -f ($FileInfo.FullName))
        }
      }
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
function Add-ISEText {
  <#
      .Synopsis
      Add text to the bottom of current ISE File

      .EXAMPLE
      Add-ISEText -InputObject (Get-Content $profile)

      .EXAMPLE
      'happy','go','lucky' | Add-ISEText

      .EXAMPLE
      Get-ChildItem 'C:\temp' | Add-ISEText
  #>
  [CmdletBinding()]
  [Alias('InISE')]
  Param(
    # Text to insert
    [Parameter(
        Mandatory,
        ValueFromPipeline
    )]
    [psobject[]]$InputObject
  )
  Begin {
    if(-not ($psISE)) {throw 'PowerShell ISE Only'}
  }
  Process {
    foreach ($Object in $InputObject) {
      $LastLineLength = $psISE.CurrentFile.Editor.GetLineLength($psISE.CurrentFile.Editor.LineCount) + 1
      if ($LastLineLength -ne 1) {
        $psISE.CurrentFile.Editor.SetCaretPosition($psISE.CurrentFile.Editor.LineCount,$LastLineLength)
        $psISE.CurrentFile.Editor.InsertText("`n")
      }
      $psISE.CurrentFile.Editor.SetCaretPosition($psISE.CurrentFile.Editor.LineCount,1)
      $psISE.CurrentFile.Editor.InsertText($Object)
    }
  }
}

 
#.ExternalHelp woztools-Help.xml
function Add-PSModulePath {
  param(
    [Parameter(Mandatory)]
    [ValidateScript({
          if (-not (Test-Path -Path $_ -PathType Container)) {
            throw '{0} - Unable to access or locate Path' -f $_
          }
          return $true
    })]
    [string]$Path,
    [switch]$PassThru
  )
  $env:PSModulePath = ($env:PSModulePath.Split(';') + (Resolve-Path -Path $Path).Path).TrimEnd('\') -join ';'
  if ($PassThru) {
    return $env:PSModulePath.Split(';')
  }
}
 
#.ExternalHelp woztools-Help.xml
function Convert-FileLength {
	[CmdletBinding()]
	[Alias('Convert-Size')]
  param(
    [Parameter(Mandatory,ValueFromPipelineByPropertyName,ValueFromPipeline)]
    [Alias('Size')]
    [long]$Length
  )
  begin {
    # TODO: Change "SizeConverter" to "LengthConverter"
	try {
    $null = [WozDev.Win32API.SizeConverter]
  }
  catch {
    Write-Verbose ' ~ Required Type not loaded, starting Add-Type process ~' -Verbose
    $MemberDef =  @'
[DllImport("Shlwapi.dll", CharSet = CharSet.Auto)]
public static extern long StrFormatByteSize(
long fileSize,
System.Text.StringBuilder buffer,
int bufferSize
);
'@
    $SizeConverter = Add-Type -Name SizeConverter -Namespace 'WozDev.Win32API' -MemberDefinition $MemberDef
  }

  }
  process {
	  if ([WozDev.Win32API.SizeConverter] -as [type]) {
	    $StringBuilder = [System.Text.StringBuilder]::new(1024)
      $null = [WozDev.Win32API.SizeConverter]::StrFormatByteSize(
	      $Length,
	      $StringBuilder,
	      $StringBuilder.Capacity
	    )
      return $StringBuilder.ToString()
	  }
	  else {
		  # Add ANSI color for missing SizeConverter
		  return $Length
	  }
  }
}

 
#.ExternalHelp woztools-Help.xml
function Convert-WSLPath {
  <#
      .Synopsis
      Covert a path in between the Windows and the WSL path formats

      .DESCRIPTION
      Use "wslpath" to convert the path

      .EXAMPLE
      # Convert Windows Path to WSL
      Convert-WSLPath -Path 'C:\temp\'

      .EXAMPLE
      # Convert WSL Path to Windows
      Convert-WSLPath -Path '/usr/bin/ssh' -ToWindows
  #>
  [CmdletBinding(DefaultParameterSetName='WSL')]
  [Alias('wslpath')]
  [OutputType()]
  Param(
    # Path to be converted
    [Parameter(
        Mandatory,
        ValueFromPipeline
    )]
    [ValidateScript({
          if(-not ($_ | Test-Path -IsValid) ){
            throw 'Path is not valid'
          }
          return $true
    })]
    [string[]]$Path,
    # Convert Path from WSL format to Windows format
    [Parameter(ParameterSetName='Win')]
    [switch]$ToWindows,
    # Convert Path from Windows format to WSL format - Default
    [Parameter(ParameterSetName='WSL')]
    [switch]$ToWSL
  )
  Begin {
    if (-not (Get-Command -Name wsl.exe -ErrorAction SilentlyContinue)) {
        throw 'Cannot locate WSL'
      }
    $ArgList = [System.Collections.ArrayList]@()
    $Results = [System.Collections.Generic.List[string]]@()
    $ConvertTo = switch ($PSCmdlet.ParameterSetName) {
      'WSL' { '-u' ; break }
      'Win' { '-w' ; break }
    }
  }
  Process {
    foreach ($Item in $Path) {
      $ArgList.AddRange((
          'wslpath',
          '-a',
          $ConvertTo,
          ([regex]::Escape($Item))
      ))
      $CPath = & wsl $ArgList 2>$null
      $Results.Add($CPath)
      $ArgList.Clear()
    }
  }
  End {
    return $Results
  }
}
 
#.ExternalHelp woztools-Help.xml
function ConvertTo-TitleCase {
  <#
      .Synopsis
      Convert Text to TitleCase

      .EXAMPLE
      ConvertTo-TitleCase -Text 'testing'

      .EXAMPLE
      Get-ChildItem -Path D:\temp | Select-Object -ExpandProperty Name | ConvertTo-TitleCase

      .INPUTS
      System.String

      .OUTPUTS
      System.String
  #>
  [OutputType([String])]
  Param(
    [Parameter(
        Mandatory,
        ValueFromPipeline
    )]
    [String[]]$Text
  )
  Process {
    foreach($Line in $Text){
      [CultureInfo]::CurrentCulture.TextInfo.ToTitleCase($Line)
    }
  }
} 
#.ExternalHelp woztools-Help.xml
function Enable-FileSizeFormat {
  [CmdletBinding()]
  param()
  Update-FormatData -PrependPath ([System.IO.Path]::Combine((Split-Path -Path $PSScriptRoot -Parent),'Lib\Formatting\MyCustomFileInfo.format.ps1xml'))
}
 
#.ExternalHelp woztools-Help.xml
function Get-ACLInfo {
  <#
      .SYNOPSIS
      Get a summary of a folder ACL

      .DESCRIPTION
      This command will examine the ACL of a given folder and create a custom object.
      The object will include a count of access rules based on the identity
      reference. Any ACL that belongs to a builtin or system account, or Everyone and
      Creator Owner, will be counted as a SystemACL. Everything else will be counted
      as a UserACL. You might use this information to identify folders or files where
      ACLS aren't what you expect.

      The custom object also contains an AccessRules property which will be a
      collection of the access rules for that object.

      SystemACL   : 7
      Owner       : BUILTIN\Administrators
      UserACL     : 1
      AccessRules : {System.Security.AccessControl.FileSystemAccessRule,
						System.Security.AccessControl.FileSystemAccessRule,
						System.Security.AccessControl.FileSystemAccessRule,
						System.Security.AccessControl.FileSystemAccessRule...}
      Path        : C:\work
      TotalACL    : 8

      It is assumed you will use this with the FileSystem provider.

      This version of the command uses a format file which is loaded "on the fly" so by default,
	  information is presented as a nicely formatted table without the AccessRules property.

      .PARAMETER Path
      The path of the folder to analyze. The default is the current directory.

      .EXAMPLE
      PS C:\> Get-ACLInfo D:\Files
      Get acl data on the Files folder.

      .EXAMPLE
      PS C:\> Get-ChildItem e:\groups\data -Recurse | Where-Object {$_.PSIsContainer} | Get-ACLInfo
      Get acl information for every folder under e:\groups\data.

      .NOTES
      NAME        :  Get-ACLInfo
      VERSION     :  0.9
      LAST UPDATED:  6/21/2012
      AUTHOR      :  Jeffery Hicks (http://jdhitsolutions.com/blog)

      .LINK
      Get-ACL

      .INPUTS
      Strings

      .OUTPUTS
      Custom object
  #>
  Param(
    [Parameter(ValueFromPipeline,ValueFromPipelineByPropertyName)]
    [ValidateScript({Test-Path -Path $_ -PathType Container})]
    [string[]]$Path = $PWD.Path
  )
  Begin {
    Write-Verbose -Message ('Starting {0}' -f $MyInvocation.MyCommand)
    $Xml = @'
<?xml version="1.0" encoding="utf-8"?>
<Configuration>
	<ViewDefinitions>
		<View>
			<Name>JDH.ACLInfo</Name>
			<ViewSelectedBy>
				<TypeName>JDH.ACLInfo</TypeName>
			</ViewSelectedBy>
			<TableControl>
				<TableHeaders/>
				<TableRowEntries>
					<TableRowEntry>
						<TableColumnItems>
							<TableColumnItem>
								<PropertyName>Path</PropertyName>
							</TableColumnItem>
							<TableColumnItem>
								<PropertyName>Owner</PropertyName>
							</TableColumnItem>
							<TableColumnItem>
								<PropertyName>TotalACL</PropertyName>
							</TableColumnItem>
							<TableColumnItem>
								<Propertyname>SystemACL</Propertyname>
							</TableColumnItem>
							<TableColumnItem>
								<Propertyname>UserACL</Propertyname>
							</TableColumnItem>
						</TableColumnItems>
					</TableRowEntry>
				</TableRowEntries>
			</TableControl>
		</View>
	</ViewDefinitions>
</Configuration>
'@
    $TempFile = [System.IO.Path]::GetTempFileName() + '.ps1xml'
    Write-Verbose -Message ('Creating {0}' -f $TempFile)
    $Xml | Out-File -FilePath $TempFile
    Write-Verbose -Message 'Updating Format Data'
    Update-FormatData -AppendPath $TempFile -ErrorAction SilentlyContinue
  }
  Process {
    Foreach ($Folder in $Path) {
      Write-Verbose -Message ('Getting ACL for {0}' -f $Folder)
      $ACL = Get-ACL -Path $Folder
      [regex]$Regex = '\w:\\\S+'
      $FolderPath = $Regex.Match($ACL.Path).Value
      $Access = $ACL.Access
      $SysACL= $Access | Where-Object {$_.IdentityReference -match 'BUILTIN|NT AUTHORITY|EVERYONE|CREATOR OWNER'}
      $NonSysACL = $Access | Where-Object {$_.IdentityReference -notmatch 'BUILTIN|NT AUTHORITY|EVERYONE|CREATOR OWNER'}
      $Obj = [PSCustomObject] @{
        Path = $FolderPath
        Owner = $ACL.Owner
        TotalACL = $Access.Count
        SystemACL = ($SysACL | Measure-Object).Count
        UserACL = ($NonSysACL | Measure-Object).Count
        AccessRules = $Access
      }
      $Obj.PSObject.TypeNames.Insert(0,'JDH.ACLInfo')
      $Obj
    }
  }
  End {
    if (Test-Path -Path $TempFile) {
      Write-Verbose -Message ('Deleting {0}' -f $TempFile)
      Remove-Item -Path $TempFile
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
Function Get-CommandParameters {
	<#
	To Do: 
	Output formating
	Include command name in output
	#>
  Param(
    [Parameter(Mandatory)]
    [ValidateScript({
          if (-Not (Get-Command -Name $_ -ErrorAction SilentlyContinue)) {
            throw 'Command does not exist'
          }
          return $true
    })]
    [string]$Command
  )
  $CPara = @(
    [System.Management.Automation.PSCmdlet]::CommonParameters
    [System.Management.Automation.PSCmdlet]::OptionalCommonParameters
  )

  (Get-Command -Name $Command).ParameterSets.Parameters | Where-Object {$_.Name -notin $CPara} |
  Select-Object -Property Name,@{n='ParameterType';e={$_.ParameterType.Name}},IsMandatory,Value*,@{n='Aliases';e={$_.Aliases -join ','}} -Unique | Format-Table -RepeatHeader
}
 
#.ExternalHelp woztools-Help.xml
function Get-ComObjects {
  [CmdletBinding()]
  param(
    [string[]]$Filter
  )
  $ListofObjects = Get-ChildItem -Path 'registry::HKEY_CLASSES_ROOT\' -ErrorAction SilentlyContinue |
  Where-Object {
	  $_.PSChildName -match '^\w+\.\w+$' -and
	  (Test-Path -Path ('{0}\CLSID' -f $_.PSPath))
	  } | Select-Object -ExpandProperty PSChildName
  if ($Filter) {
    $ListofObjects | Where-Object {$_ -match ($Filter -join '|')}
  }
  else {
    $ListofObjects
  }
}
 
#.ExternalHelp woztools-Help.xml
Function Get-CurrentUser {
  [CmdletBinding()]
  [Alias('CUser')]
  param()
  [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
}

 
#.ExternalHelp woztools-Help.xml
function Get-EnumerateFiles {
  Param(
    [Parameter(Mandatory)]
    [string]$Path,
    [string]$Filter = '*',
    [switch]$Recurse
  )
  begin {
    try {  
      $AlphaFSDll = [System.IO.Path]::Combine((Split-Path -Path $PSScriptRoot -Parent),'Lib\AlphaFS\Net452\AlphaFS.dll')
      $null = [System.Reflection.Assembly]::LoadFile($AlphaFSDll)
    }
    catch {
      [System.Management.Automation.ErrorRecord]$e = $_
      [PSCustomObject]@{
        Type      = $e.Exception.GetType().FullName
        Exception = $e.Exception.Message
        Reason    = $e.CategoryInfo.Reason
        Target    = $e.CategoryInfo.TargetName
        Script    = $e.InvocationInfo.ScriptName
        Line      = $e.InvocationInfo.ScriptLineNumber
        Column    = $e.InvocationInfo.OffsetInLine
      }
    }

    function Invoke-GenericMethod {
      [CmdletBinding()]
      Param(
        $Instance,
        [string]$MethodName,
        [type[]]$TypeParameters,
        [object[]]$MethodParameters
      )
      [System.Collections.ArrayList]$private:ParameterTypes = @{}
      foreach ($private:ParamType In $MethodParameters) {$null = $ParameterTypes.Add($ParamType.GetType())}
      $private:Method = $Instance.GetMethod($MethodName, 'Instance,Static,Public', $null, $ParameterTypes, $null)
      if ($null -eq $Method) {
        throw ('Method: [{0}]::{1} not found.' -f $Instance.ToString(),$MethodName)
      }
      else {
        $Method = $Method.MakeGenericMethod($TypeParameters)
        $Method.Invoke($Instance, $MethodParameters)
      }
    }
    $AlphaFiles = [System.Collections.ArrayList]@()
    
    
    if ($Recurse) {
      $DirectoryEnumerationOptions = [Alphaleonis.Win32.Filesystem.DirectoryEnumerationOptions]'FilesAndFolders, Recursive, SkipReparsePoints, ContinueOnException'
    }
    else {
      $DirectoryEnumerationOptions = [Alphaleonis.Win32.Filesystem.DirectoryEnumerationOptions]'FilesAndFolders, SkipReparsePoints, ContinueOnException'
    }
  }
  process {
  
    $SplattAlpha = @{
      Instance = ([Alphaleonis.Win32.Filesystem.Directory])
      MethodName = 'EnumerateFileSystemEntryInfos'
      TypeParameters = 'Alphaleonis.Win32.Filesystem.FileSystemEntryInfo'
      MethodParameters = $Path, $Filter, $DirectoryEnumerationOptions, ([Alphaleonis.Win32.Filesystem.PathFormat]::FullPath)
    }
    # $SplattAlpha
    foreach ($private:Folder in (Invoke-GenericMethod @SplattAlpha)) {
      # $Folder.FullPath
      $null = $AlphaFiles.Add($Folder)
    }
    $AlphaFiles
  }
}







 
#.ExternalHelp woztools-Help.xml
function Get-EnvPath {
  [CmdletBinding()]
  param(
    [System.EnvironmentVariableTarget]$VariableTarget = [System.EnvironmentVariableTarget]::Machine
  )
  $PathSort = ([System.Environment]::GetEnvironmentVariable('PATH',$VariableTarget)).Split(';').TrimEnd('\') | Sort-Object
  Return $PathSort
}
 
#.ExternalHelp woztools-Help.xml
function Get-FunctionCode {
  <#
      .Synopsis
      Get the code of a powershell function or filter
      .EXAMPLE
      # Gets the code for New-Guid
      Get-FunctionCode New-Guid
      .EXAMPLE
      # Outputs the code for New-Guid into a new PowerShell ISE Tab
      Get-FunctionCode -Function New-Guid -OutISE
      .EXAMPLE
      # Gets the code for New-Guid and saves it to V:\temp\New-Guid.ps1
      Get-FunctionCode New-Guid -OutFile V:\temp\New-Guid.ps1
      .EXAMPLE
      # Outputs the code for New-Guid into a new PowerShell ISE Tab and saves it to V:\temp\New-Guid.ps1
      Get-FunctionCode -Function New-Guid -OutISE -OutFile V:\temp\New-Guid.ps1
  #>
  Param(
    # Function Name
    [Parameter(Mandatory)]
    [ValidateScript({
          if (-not (Get-Command -Name $_ -CommandType Function,Filter -ErrorAction SilentlyContinue)) {
            throw ('Cannot find function - {0}' -f $_)
          }
          return $true
    })]
    [String]$Function,
    [ValidateScript({
          if (-not ($psISE)) {
            throw ('{0}-OutISE can only be use within PowerShell ISE' -f ("`n"))
          }
          return $true
    })]
    [switch]$OutISE,
    [ValidateScript({
          if($_ | Test-Path -PathType Leaf) {
            throw 'File already exists'
          }
          return $true
    })]
    [string]$OutFile
  )
  Process {
    $CmdInfo = Get-Command -Name $Function -CommandType Function,Filter
    $FCode = '{0} {1} {3}{2}{4}' -f $CmdInfo.CommandType,$CmdInfo.Name,$CmdInfo.Definition,('{'),('}')
    $FCode = ($FCode.Split("`n") | ForEach-Object { $_ -replace '\s*$' }) -join "`n"
    if($OutISE) {
      $IseFile1 = $psISE.CurrentPowerShellTab.Files.Add()
      $IseFile1.Editor.Text = $FCode
      $IseFile1.Editor.SetCaretPosition(1,1)
      if($OutFile) {
        $IseFile1.SaveAs($OutFile,[System.Text.UTF8Encoding]::new($false))
      }
    }
    else {
      if($OutFile) {
        [System.IO.File]::WriteAllLines($OutFile,$FCode,[System.Text.UTF8Encoding]::new($false))
      }
      $FCode | Write-Output
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
function Get-GitHubUserRepos {
  <#
      .Synopsis
      Download GitHub User Gists & Repositories

      .DESCRIPTION
      Uses git.exe to clone the gists and repositories of a github user.
      Can Exclude repositories with names that match the string/strings defined with -Exclude
      Requires Module - PowerShellForGitHub
      Requires git.exe

      I included the source file for PForEach because it is no longer visible in the powershellgallery and github
      Vasily Larionov - https://www.powershellgallery.com/profiles/vlariono | https://github.com/vlariono
      PForEach - https://www.powershellgallery.com/packages/PForEach

      .EXAMPLE
      Get-GitHubUserRepos -UserName WozNet -Path 'V:\git\users' -Exclude 'docs'

      .EXAMPLE
      'WozNet','PowerShell','Microsoft' | Get-GitHubUserRepos -Path 'V:\git\users' -Exclude 'azure,'office365'
  #>
  [CmdletBinding()]
  [Alias('dlgit')]
  Param(
    # Param1 help - GitHub Usernames
    [Parameter(
        Mandatory,
        HelpMessage='Github UserName',
        ValueFromPipeline
    )]
    [ValidateNotNullOrEmpty()]
    [String[]]$UserName,

    # Param2 help - Directory to save User Gists and Repositories
    [ValidateScript({
          Test-Path -Path $_ -PathType Container
    })]
    [String]$Path = 'V:\git\users',

    # Param3 help - Exclude Repositories with Names matching these strings
    [String[]]$Exclude = 'docs',

    # Param4 help - ThrottleLimit for Invoke-ForEachParallel
    [int]$ThrottleLimit = 5
  )
  Begin {

    #####region Load Progress helper function

    function Write-MyProgress {
      <#
          .SYNOPSIS
          Displays a progress bar within a Windows PowerShell command window.

          .DESCRIPTION
          The Write-Progress cmdlet displays a progress bar in a Windows PowerShell command window that depicts the status of a running command or script.

          .NOTES
          File Name   : Write-MyProgress.ps1
          Author      : Woz
          Date        : 2017-05-10
          Last Update : 2023-01-14
          Version     : 2.0.0

          .PARAMETER id
          Specifies an ID that distinguishes each progress bar from the others.

          .PARAMETER ParentId
          Specifies the parent activity of the current activity.

          .PARAMETER StartTime
          StartTime of the foreach processing

          .PARAMETER Object
          Object use in your foreach processing

          .PARAMETER Count
          Foreach Count variable

          .EXAMPLE
          $GetProcess = Get-Process

          $Count = 0
          $StartTime = Get-Date
          foreach($Process in $GetProcess) {
          $Count++
          Write-MyProgress -StartTime $StartTime -Object $GetProcess -Count $Count

          Write-Host "-> $($Process.ProcessName)"
          Start-Sleep -Seconds 1
          }

          .LINK
          Source
          https://github.com/Netboot-France/Write-MyProgress
      #>
      Param(
        [Parameter(Mandatory)]
        [Array]$Object,
        [Parameter(Mandatory)]
        [DateTime]$StartTime,
        [Parameter(Mandatory)]
        [Int]$Count,
        [Int]$Id=1,
        [Int]$ParentId=-1
      )

      $SecondsElapsed = ((Get-Date) - $StartTime).TotalSeconds
      $SecondsRemaining = ($SecondsElapsed / ($Count / $Object.Count)) - $SecondsElapsed
      $PercentComplete = ($Count/$($Object.Count)) * 100

      $Argument = @{}
      $Argument.Add('Activity', ('Processing {0} of {1}' -f $Count, $Object.Count))
      $Argument.Add('PercentComplete', $PercentComplete)
      $Argument.Add('CurrentOperation', ('{0:N2}% Complete' -f $PercentComplete))
      $Argument.Add('SecondsRemaining', $SecondsRemaining)

      if($Id -ne $null) { $Argument.Add('Id', $Id) }
      if($ParentId -ne $null) { $Argument.Add('ParentId', $ParentId) }

      Write-Progress @Argument
    }
    #####endregion 


    try{
      if (-not (Get-Command -Name git.exe)) { throw 'git.exe is missing' }
      if (-not (Get-Module -ListAvailable -Name PowerShellForGitHub)) { throw 'Install Module - PowerShellForGitHub' }
      Import-Module -Name PowerShellForGitHub -PassThru:$false
      if (-not (Get-Command -Name Invoke-ForEachParallel -ErrorAction SilentlyContinue)) {
        # Import-Module -Name (Join-Path -Path (Split-Path -Path $PSScriptRoot -Parent) -ChildPath 'Lib\PForEach\PForEach.dll' -Resolve) -PassThru:$false -ErrorAction Stop
        Import-Module -Name ([System.IO.Path]::Combine((Split-Path -Path $PSScriptRoot -Parent),'Lib\PForEach\PForEach.dll')) -PassThru:$false -ErrorAction Stop
      }
      if (-not (Get-GitHubConfiguration -Name DisableTelemetry)) { Set-GitHubConfiguration -DisableTelemetry }
      if (-not (Test-GitHubAuthenticationConfigured)) { $Host.UI.WriteErrorLine('PowerShellForGitHub is not Authenticated') }
    }
    catch {
      [System.Management.Automation.ErrorRecord]$e = $_
      [PSCustomObject]@{
        Type      = $e.Exception.GetType().FullName
        Exception = $e.Exception.Message
        Reason    = $e.CategoryInfo.Reason
        Target    = $e.CategoryInfo.TargetName
        Script    = $e.InvocationInfo.ScriptName
        Line      = $e.InvocationInfo.ScriptLineNumber
        Column    = $e.InvocationInfo.OffsetInLine
      }
      throw $_
    }
    $HTML = @'
<script src='https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js'></script>
<div id="ph"></div>
<script>
var username = '---'
$.getJSON('https://api.github.com/users/' + username + '/gists', function (data) {
    for (var i in data) {
        var oldDocumentWrite = document.write
        document.write = function (scr_content) {
            for (var i in data) {
                if ( $.trim( $("#" + data[i].id ).text() ).length == 0 ) {
                    $("#" + data[i].id ).append(scr_content);
                    return;
                }
            }
        }
        var scr = document.createElement('script');
        scr.src = 'https://gist.github.com/' + username + '/' + data[i].id + '.js';
        $("#ph").append("<div><h2>" + data[i].description + "</h2></div>");
        $("#ph").append(scr.outerHTML);
        $("#ph").append('<div id="' + data[i].id + '"></div>');
    }
    document.write = oldDocumentWrite;
});
</script>
'@
    $UserPathList = [System.Collections.Generic.List[string]]@()
    $StopWatch = [System.Diagnostics.Stopwatch]::New()
    $StopWatch.Start()
  }
  Process {

    $DelDir = [System.Collections.Generic.List[string]]@()
    foreach ($GitUser in $UserName) {
      $UserPath = [System.IO.Path]::Combine($Path,$GitUser)
      if (Test-Path -Path $UserPath -PathType Container) {
        Get-GitHubRepository -OwnerName $GitUser | Sort-Object -Property updated_at -Descending | ForEach-Object -Process {
          if ( $LPath = Join-Path -Path $UserPath -ChildPath $_.Name -Resolve -ErrorAction SilentlyContinue | Get-Item ) {
            [PSCustomObject]@{
              Name = $_.Name
              Git_Updated = $_.updated_at
              Local_Updated = $LPath.LastWriteTime
              GetItem = $LPath
            }
          }
        } | Where-Object {$_.Git_Updated -ge $_.Local_Updated} | Select-Object -ExpandProperty GetItem | ForEach-Object {
          $DelDir.Add($PSItem)
        }
      }
    }
    if ($DelDir) {
      Remove-Item -Path $DelDir -Recurse -Force
      if (Resolve-Path -Path $DelDir -ErrorAction Ignore) { Remove-Item -Path $DelDir -Recurse -Force }
    }
    Remove-Variable -Name DelDir -ErrorAction Ignore

    # Download
    foreach ($GitUser in $UserName) {
      $UserPath = [System.IO.Path]::Combine($Path,$GitUser)
      $UserPathList.Add($UserPath)

      if (-not (Test-Path -Path $UserPath)) { New-Item -Path $UserPath -ItemType Directory }

      # Get Gist
      $UserGist = Get-GitHubGist -UserName $GitUser
      if ($UserGist) {
        $GistDir = [System.IO.Path]::Combine($UserPath,'_gist')
        $TempGistDir = [System.IO.Path]::Combine($UserPath,'_tempgist')
        if (-not (Test-Path -Path $GistDir)) { New-Item -Path $GistDir -ItemType Directory }
        if (-not (Test-Path -Path $TempGistDir)) { New-Item -Path $TempGistDir -ItemType Directory }

        Get-ChildItem -Path $GistDir | Remove-Item -Recurse -Force
        Set-Content -Value ($HTML.Replace('---',$GitUser)) -Path ([System.IO.Path]::Combine($UserPath,'_gist.html')) -Force
        Write-Output ('{2}{0} Gists - {1}' -f $GitUser,$UserGist.Count,("`n"))

        ### Start Downloading Gist to temp dir
        $Count = 0
        $StartTime = Get-Date
        $UserGist | ForEach-Object -Process {
          $Count++
          Write-MyProgress -StartTime $StartTime -Object $UserGist -Count $Count
          $UGist = $PSItem
          Start-Process -WorkingDirectory $TempGistDir -FilePath git.exe -ArgumentList ('clone --recursive {0}' -f $UGist.git_pull_url) -WindowStyle Hidden -Wait
          $UGist = $null
          Start-Sleep -Milliseconds 100
        }

        ### Start Moving Gist from temp dir to $GistDir
        Get-ChildItem $TempGistDir | ForEach-Object {
          $TGDir = $_
          Join-Path -Path $TGDir -ChildPath '.git' -Resolve | Remove-Item -Recurse -Force
          $TGFiles = $TGDir | Get-ChildItem -Force:$false
          $TGFileCount = $TGFiles.Count
          if ($TGFileCount -eq 1) {
            try {
              $TGFiles | Move-Item -Destination $GistDir -PassThru:$false -ErrorAction Stop
            }
            catch [System.IO.IOException] {
              'Shit happened! Attempting to rename and try moving again - {0}' -f $TGFiles.Name | Write-Warning
              $TGFiles | Rename-Item -NewName {$_.Name.Replace($_.BaseName,('{0}-{1}' -f $_.BaseName,$_.Directory.Name.Substring(0,6)))} -PassThru | Move-Item -Destination $GistDir -PassThru:$false -ErrorAction Stop
            }
            $MCheck = $TGDir | Get-ChildItem -Force:$false
            if ($MCheck.Count -eq 0) { Remove-Item -Path $TGDir -Recurse -Force }
          }
          else {
            try {
              $TGDir | Move-Item -Destination $GistDir -PassThru:$false -ErrorAction Stop
            }
            catch [System.IO.IOException] {
              Write-Error $_
            }
          }
        }
        ### Cleaning up Temp Gist Dir
        Remove-Item -Path $TempGistDir -Recurse -Force
      }

      # Get Repo
      $UserRepo = Get-GitHubRepository -OwnerName $GitUser
      $FilteredUserRepo = switch ($Exclude.Count) {
        {$_ -ge 1} { $UserRepo | Where-Object {$_.name -notmatch ($Exclude -join '|')} ; break }
        default { $UserRepo ; break }
      }
      Write-Output ('{0}{1} Repositories - {2} (excluded - {3})' -f "`n",$GitUser,$FilteredUserRepo.Count,($UserRepo.Count - $FilteredUserRepo.Count))
      $FilteredUserRepo.name| Select-Object -Property @{e={if ($_.Length -gt 27) {$_.Substring(0,24) + '...'} else{$_}}} | Format-Wide -AutoSize
      $FilteredUserRepo | Invoke-ForEachParallel -ThrottleLimit $ThrottleLimit -Process {
        Start-Process -WorkingDirectory $UserPath -FilePath git.exe -ArgumentList ('clone --recursive {0}' -f $PSItem.clone_url) -WindowStyle Hidden -Wait

        Start-Sleep -Milliseconds 150

        $RepoDir = Get-Item -Path (Join-Path -Path $UserPath -ChildPath $PSItem.name -Resolve)
        $RepoDir.LastWriteTime = $PSItem.updated_at
      }
    }
  }
  End {
    $StopWatch.Stop()
    'Time - {0:m\:ss}{1}' -f $StopWatch.Elapsed,("`n")
    'Updated User Directories:'
    $UserPathList
  }
}

 
filter Get-HostEntry {
  [CmdletBinding(PositionalBinding)]
  [OutputType([System.Net.IPHostEntry])]
  param(
    [Parameter(Mandatory,ValueFromPipeline)]
    [ValidateScript({
          if ($_ -as [uri]) {
            return $true
          }
          elseif($_ -as [ipaddress]) {
            return $true
          }
          else {
            throw 'Must be an ipaddress ([address]) or hostname ([uri])'
          }
    })]
    [string[]]$Address
  )
  begin {
    if (-not ($PSBoundParameters.ContainsKey('ErrorAction'))){
      Write-Verbose -Message ' ----- Setting ErrorActionPreference to SilentlyContinue ----- '
      $script:ErrorActionPreference = 'SilentlyContinue'
    }
    $R = [System.Collections.Generic.List[System.Net.IPHostEntry]]@()
  }
  process {
    foreach ($A in $Address) {
      $HE = [System.Net.Dns]::GetHostEntry($A)
      $R.Add($HE)
      $HE = $null
    }
  }
  end {
    return $R
  }
}









 
#.ExternalHelp woztools-Help.xml
function Get-ItemFromClipboard {
  <#
      .Synopsis
      Get file path from clipboard

      .DESCRIPTION
      Trims single and double quotes from path stored in clipboard then passes results to Get-Item
      Designed for taking the clipboard contents from Windows Explorer "Copy Path" into PowerShell.
  #>
  try {
    (Get-Clipboard).Trim('"',"'") | Where-Object {(Test-Path -Path $_ ) -eq $true} | Get-Item -ErrorAction Ignore
  }
  catch {
    [System.Management.Automation.ErrorRecord]$e = $_
    [PSCustomObject]@{
      Type      = $e.Exception.GetType().FullName
      Exception = $e.Exception.Message
      Reason    = $e.CategoryInfo.Reason
      Target    = $e.CategoryInfo.TargetName
      Script    = $e.InvocationInfo.ScriptName
      Line      = $e.InvocationInfo.ScriptLineNumber
      Column    = $e.InvocationInfo.OffsetInLine
    }
    # throw $_
  }
}
 
Function Get-RedirectedUrl {
  Param(
    [Parameter(Mandatory,ValueFromPipeline)]
    [ValidateScript({
          if (-not ([System.Uri]::IsWellFormedUriString($_,[System.UriKind]::Absolute))) {
            throw ('{0}{1} - Failed URL Validation' -f "`n",$_)
          }
          return $true
    })]
    [String]$Url
  )
  begin {
    $RUrls = [System.Collections.Generic.List[string]]::new()
  }
  process {
    $Request = [System.Net.WebRequest]::Create($Url)
    $Response = $Request.GetResponse()
    $RUrls.Add($Response.ResponseUri.ToString())
    $Response.Close()
    $Response.Dispose()
  }
  end {
    return $RUrls
  }
}

 
#.ExternalHelp woztools-Help.xml
function Get-RelativePath {
  param(
    [Parameter(Mandatory)]
    [ValidateScript({
          if (-not ($_|Test-Path -PathType Container -IsValid)) {
            throw 'invalid directory path'
          }
          return $true
    })]
    [string]$RelativeTo,
    [Parameter(ValueFromPipeline,Mandatory)]
    [ValidateScript({
          if (-not ($_|Test-Path -IsValid)) {
            throw 'invalid path'
          }
          return $true
    })]
    [string]$Path
  )
  process {
    [System.IO.Path]::GetRelativePath($RelativeTo,$Path)
  }
}


 
#.ExternalHelp woztools-Help.xml
function Get-StringFromSecureString {
  <#
      .Synopsis
      Decrypt SecureString

      .DESCRIPTION
      Convert securestring to string with
      [Microsoft.PowerShell.DesiredStateConfiguration.Internal.DscClassCache]::GetStringFromSecureString

      .EXAMPLE
      $test = Get-Credential # Username - Tester, Password test1
      $test.Password | Get-StringFromSecureString

      .EXAMPLE
      Get-StringFromSecureString -SecureString $test.Password

      .INPUTS
      securestring

      .OUTPUTS
      string
  #>
  [CmdletBinding()]
  [Alias('Convert-SecureString')]
  [OutputType([String])]
  Param(
    [Parameter(
        Mandatory,
        ValueFromPipeline,
        ValueFromPipelineByPropertyName
    )]
    [Alias('Password')]
    [ValidateNotNullOrEmpty()]
    [securestring]$SecureString
  )
  Process {
    [Microsoft.PowerShell.DesiredStateConfiguration.Internal.DscClassCache]::GetStringFromSecureString($SecureString)
  }
}
 
#.ExternalHelp woztools-Help.xml
function Invoke-Beep {
  <#
      .SYNOPSIS
      Invoke Console Beep

      .PARAMETER Freq
      Frequency of the beep, ranging from 37 to 32767 hertz

      .PARAMETER Duration
      Duration of the beep measured in milliseconds

      .EXAMPLE
      Invoke-Beep -Freq 700 -Duration 300
  #>
  [CmdletBinding()]
  [Alias('Beep')]
  param(
    [ValidateRange(37,32767)]
    [int]$Freqency = 800,
    [int]$Duration = 200
  )
  [System.Console]::Beep($Freqency,$Duration)
}
 
#.ExternalHelp woztools-Help.xml
function Invoke-GitClone {
  <#
      .Synopsis
      Clone a Git Repository

      .EXAMPLE
      Invoke-GitClone -Repo https://github.com/Woznet/WozTools.git -Path D:\git\repos
  #>
  [CmdletBinding()]
  [Alias('Clone-GitRepo')]
  [Alias('cgit')]
  param(
    # Git Repository to Clone
    [Parameter(Mandatory,ValueFromPipeline)]
    [String[]]$Repo,
    # Location the repository folder will be saved to
    [ValidateScript({
          if(-Not ($_ | Test-Path -PathType Container)) {
            throw ('Unable to locate - {0}' -f $_)
          }
          return $true
    })]
    [String]$Path
  )
  Begin {
    if (-not ([Environment]::GetEnvironmentVariable('GIT_REDIRECT_STDERR') -eq '2>&1')) {
      [Environment]::SetEnvironmentVariable('GIT_REDIRECT_STDERR','2>&1',[System.EnvironmentVariableTarget]::Process)
      Start-Sleep -Seconds 1
      Update-SessionEnvironment
    }
    if (-not (Get-Command -Name git.exe)) { throw 'Install git.exe' }
    $RepoDir = [System.Collections.ArrayList]@()
    $null = $RepoDir.Add('')
  }
  Process {
    Invoke-InDirectory -Path $Path -ScriptBlock {
      foreach ($RepoUrl in $Repo) {
        $null = $RepoDir.Add([System.IO.Path]::Combine($Path, ((Split-Path -Path $RepoUrl -Leaf).Split('.')[0])))
        git clone --recurse-submodules $RepoUrl
      }
    }
  }
  end {
    $RepoDir
  }
}
 
#.ExternalHelp woztools-Help.xml
function Invoke-InDirectory {
  # https://gist.github.com/chriskuech/a32f86ad2609719598b073293d09ca03#file-tryfinally-2-ps1
  Param(
    [Parameter(Mandatory,ValueFromPipeline)]
    [ValidateScript({
          if(-not (Test-Path -Path $_ -PathType Container)) {
            throw 'Folder does not exist'
          }
          return $true
    })]
    [String[]]$Path,
    [Parameter(Mandatory)]
    [ValidateNotNullOrEmpty()]
    [scriptblock]$ScriptBlock
  )
  process {
    foreach($Loc in $Path) {
      try {
        Push-Location -Path $Loc
        & $ScriptBlock
      }
      finally {
        Pop-Location
      }
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
Function Invoke-psEdit {
  [Alias('psEdit')]
  param(
    [Parameter(
        ValueFromPipelineByPropertyName,
        ValueFromPipeline,
        Mandatory
    )]
    [Alias('FullName')]
    [ValidateScript({
          if (-not (Test-Path -Path $_)) {
            throw '{1}Something went wrong.{1}Check Path - {0}' -f $_,"`n"
          }
          return $true
    })]
    [string[]]$Path
  )
  Begin {
    if (-not ($psISE)) { throw 'PowerShell ISE Only' }
    Write-Verbose -Message ('Starting - {0}' -f $MyInvocation.MyCommand)
  }
  Process {
    foreach ($FileName in ($ExecutionContext.SessionState.Path.GetResolvedPSPathFromPSPath($Path))) {
      Write-Verbose -Message ('Opening - {0}' -f $FileName)
      $null = $psISE.CurrentPowerShellTab.Files.Add($FileName)
    }
  }
  End {
    Write-Verbose -Message ('Ending - {0}' -f $MyInvocation.Mycommand)
  }
}
 
#.ExternalHelp woztools-Help.xml
function Invoke-ReArmLicense {
  [CmdletBinding(DefaultParameterSetName='Rearm')]
  [Alias('ReArm')]
  param(
    [Parameter()]
    [ValidateScript({
          if (-not (Test-Connection -Quiet -Count 1 -ComputerName $_)) {
            throw '{0} - Computer Unavailable' -f $_
          }
          return $true
    })]
    [string[]]$ComputerName = $env:COMPUTERNAME,
    [Parameter(ParameterSetName='Grace')]
    [switch]$GracePeriod,
    [switch]$Restart,
    [switch]$Force
  )
  foreach ($Computer in $ComputerName) {
    $Cim = New-CimSession -ComputerName $Computer
    $SLP = Get-CimInstance -ClassName 'SoftwareLicensingProduct' -CimSession $Cim
    try {
      $GraceLeft = [DateTime]::Now.Add([TimeSpan]::FromMinutes($SLP.GracePeriodRemaining))
    }
    catch {
	  Write-Warning -Message 'Grace peroid has ended, evaluation has expired! Using current date.'
      $GraceLeft = Get-Date
    }
    switch ($PSCmdlet.ParameterSetName) {
      'Grace' {
        [pscustomobject] @{
          ComputerName = $Computer
          Date = $GraceLeft.ToShortDateString()
          RemainingReArmCount = $SLP.RemainingSkuReArmCount
        }
        break
      }
      default {
        if (($GraceLeft.AddDays(-7) -le (Get-Date)) -or $Force) {
          $SLS = Get-CimInstance -ClassName 'SoftwareLicensingService' -CimSession $Cim
          if ($SLS.RemainingWindowsReArmCount -gt 0) {
            $SLS | Invoke-CimMethod -MethodName 'ReArmWindows'
            if ($Restart) { Restart-Computer -ComputerName $Computer -Force }
          }
          else {
            throw '{0} - Windows ReArm Count: 0' -f $Computer
          }
        }
        else {
          Write-Output ('{0}: Evaluation License expires: {1}{2}Use -Force to ReArm now' -f $Computer,$GraceLeft.ToShortDateString(),("`n"))
        }
        break
      }
    }
  }
}

 
#.ExternalHelp woztools-Help.xml
function Join-Url {
<#
  
  
#>
  [CmdletBinding()]
  param(
    [Parameter(Mandatory,ValueFromPipeline)]
    [uri]$Base,
    [Parameter(Mandatory)]
    [string]$Child,
    [switch]$OutUri
  )
  process {
    if (-not ($Base.ToString().EndsWith('/'))) {
      [uri]$Base = '{0}/' -f $Base.ToString()
    }
    $Uri = [uri]::new($Base,$Child.TrimStart('/'))
    if ($OutUri) {
      return $Uri
    }
    else {
      return $Uri.ToString()
    }
  }
}
 
function New-ANSIString {
  <#
      .Synopsis
      Generate ANSI escape code string for outputing text with color

      .DESCRIPTION
      Create ANSI color escape code using a RGB color value

      .EXAMPLE
      # Create variable with desired color
      $ANSI1 = New-ANSIString
      # Create variable to reset ANSI effects
      $Reset = New-ANSIString -Reset
      # String getting colored
      $Text = 'This is a test.  More testing... and testing'

      '{0}{1}{2}' -f $ANSI1,$Text,$Reset

      .EXAMPLE
      # Create variable with desired foreground color
      $ANSIFG1 = New-ANSIString -Red 55 -Green 120 -Blue 190 -Foreground
      # Create variable with desired background color
      $ANSIBG1 = New-ANSIString -Green 100 -Background
      # Create variable to reset ANSI effects
      $Reset = New-ANSIString -Reset
      # String getting colored
      $Text = 'This is a test.  More testing... and testing'
      $Text2 = 'More and more and more!'

      '{0}{1}{2}{3}{4}' -f $ANSIFG1,$Text,$ANSIBG1,$Text2,$Reset

      .OUTPUTS
      [string]

      .NOTES
      FYI: Remeber to reset the text style after every stylized text, otherwise the ANSI effects will continue to be applied to all that get output later.
  #>
  [CmdletBinding(
      DefaultParameterSetName='Foreground'
  )]
  [Alias('Get-ANSI')]
  [OutputType([String])]
  Param(
    # Param1 help description
    [Parameter(
        ParameterSetName = 'Foreground',
        Position = 0
    )]
    [Parameter(
        ParameterSetName = 'Background',
        Position = 0
    )]
    [ValidateRange(0,255)]
    [int]$Red = (Get-Random -Minimum 0 -Maximum 255),
    # Param2 help description
    [Parameter(
        ParameterSetName = 'Foreground',
        Position = 1
    )]
    [Parameter(
        ParameterSetName = 'Background',
        Position = 1
    )]
    [ValidateRange(0,255)]
    [int]$Green = (Get-Random -Minimum 0 -Maximum 255),
    # Param3 help description
    [Parameter(
        ParameterSetName = 'Foreground',
        Position = 2
    )]
    [Parameter(
        ParameterSetName = 'Background',
        Position = 2
    )]
    [ValidateRange(0,255)]
    [int]$Blue = (Get-Random -Minimum 0 -Maximum 255),
    # Param4 help description
    [Parameter(ParameterSetName='Foreground')]
    [switch]$Foreground,
    # Param5 help description
    [Parameter(ParameterSetName='Background')]
    [switch]$Background,
    # Param6 help description
    [Parameter(ParameterSetName='Reset')]
    [switch]$Reset
  )
  Process {
    switch ($PSCmdlet.ParameterSetName) {
      'Foreground' { 
        return ('{0}[38;2;{1};{2};{3}m' -f ([char]27), $Red, $Green, $Blue)
      }
      'Background' { 
        return ('{0}[48;2;{1};{2};{3}m' -f ([char]27), $Red, $Green, $Blue)
      }
      'Reset' {
        return ('{0}[0m' -f ([char]27))
      }
      default {
        throw 'something went wrong....'
      }
    }
  }
}


 
#.ExternalHelp woztools-Help.xml
function New-DirandEnter {
  [CmdletBinding()]
  [Alias('mdc')]
  param(
    [Parameter(Mandatory)]
    [ValidateScript({
          if(-not ($_ | Test-Path -PathType Container)) {
            throw 'Folder exists'
          }
          return $true
    })]
    [String]$Path
  )
  New-Item -Path $Path -ItemType Directory -Force | Set-Location
}

 
#.ExternalHelp woztools-Help.xml
function New-Shortcut{
  param(
    [Parameter(Mandatory)]
    [ValidateScript({
          if (-not(Test-Path -Path $_)) {
            throw '{0} - Invalid -Target' -f $_
          }
          return $true
    })]
    [String]$Target,
    [Parameter(Mandatory)]
    [ValidateScript({
          if (-not(Test-Path -Path $_ -IsValid)) {
            throw '{0} - ShortcutFile Path is Invalid' -f $_
          }
          if(-not (Test-Path -Path $_)) {
            throw '{0} already exists' -f $_
          }
          if(-not ($_ -match '[.lnk]')) {
            throw '{0} must end in .lnk' -f $_
          }
          return $true
    })]
    [String]$ShortcutFile,
    [string]$Arguments,
    [switch]$RunAsAdmin
  )
  begin{
    $WScriptShell = New-Object -ComObject WScript.Shell
  }
  process{
    $Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
    $Shortcut.TargetPath = $Target
    if ($Arguments) {$Shortcut.Arguments = $Arguments}
    $Shortcut.Save()
    Write-Verbose -Message 'Shortcut Saved'# -Verbose:$VerbosePreference

    if($RunAsAdmin) {
      $Bytes = [System.IO.File]::ReadAllBytes($ShortcutFile)
      $Bytes[0x15] = $Bytes[0x15] -bor 0x20
      [System.IO.File]::WriteAllBytes($ShortcutFile, $Bytes)
      Write-Verbose -Message ('{0} - Set to Run as Admin' -f $ShortcutFile)# -Verbose:$VerbosePreference
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
function Open-NotepadPlusPlus {
  <#
      .Synopsis
      Open file in NotepadPlusPlus

      .EXAMPLE
      Open-NotepadPlusPlus -Path .\Path\of\a\File.ps1

      .EXAMPLE
      ### BAD EXAMPLE - funciton is stupid and will open all resolved paths
      gci .\* | Open-NotepadPlusPlus

      .INPUTS
      FileInfo, String

      .OUTPUTS
      none

      .NOTES
      assumes notepad++.exe is within $env:PATH
      Install with chocolatey if needed
  #>
  [Alias('npp','Open-NPP')]
  param (
    # [Parameter(ValueFromPipeline)]
    [Parameter(ValueFromPipelineByPropertyName,ValueFromPipeline)]
    [Alias('FullName')]
    [ValidateScript({
          if( -not ($_ | Test-Path -PathType Leaf) ) {
            throw 'File does not exist'
          }
          return $true
    })]
    [String[]]$Path
  )
  begin {
    if (-not (Get-Command -Name 'notepad++.exe' -ErrorAction Ignore)) {
      throw 'Install notepad++'
    }
  }
  process {
    if ($Path) {
      try {
        foreach($File in ($ExecutionContext.SessionState.Path.GetResolvedPSPathFromPSPath($Path))){
          & notepad++.exe $File
        }
      }
      catch {
        [System.Management.Automation.ErrorRecord]$e = $_
        [PSCustomObject]@{
          Type      = $e.Exception.GetType().FullName
          Exception = $e.Exception.Message
          Reason    = $e.CategoryInfo.Reason
          Target    = $e.CategoryInfo.TargetName
          Script    = $e.InvocationInfo.ScriptName
          Line      = $e.InvocationInfo.ScriptLineNumber
          Column    = $e.InvocationInfo.OffsetInLine
        }
        Write-Warning $_
      }
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
function Open-Script {
  [CmdletBinding()]
  [Alias('Open')]
  Param(
    [Parameter(Mandatory,ValueFromPipeline)]
    [ValidateScript({($_ | Test-Path -PathType Leaf)})]
    [String[]]$Path
  )
  Process {
    foreach($File in $Path){
      switch ($psISE) {
        $true {
          $null = $psISE.CurrentPowerShellTab.Files.Add((Get-Item -Path $File).FullName) ; break
        }
        $false {
          & powershell_ise.exe -File (Get-Item -Path $File).FullName ; break
        }
      }
      Start-Sleep -Milliseconds 500
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
Function Out-ISETab {
  Param(
    [Parameter(Mandatory,ValueFromPipeline)]
    [psobject]$InputObject,
    [ValidateScript({
          if ($_ | Test-Path) {
            throw 'Choose a path that does not exist.'
          }
          return $true
    })]
    [System.IO.FileInfo]$SaveAs
  )
  Begin {
    if(-not ($psISE)){ throw 'Must run in PowerShell ISE' }
    $Data = @()
  }
  Process {
    $Data += $InputObject
  }
  End {
    $NewFile = $psISE.CurrentPowerShellTab.Files.Add()
    $NewFile.Editor.InsertText(($Data | Out-String))
    $NewFile.Editor.SetCaretPosition(1,1)
    if ($SaveAs) {
      Write-Verbose -Message ('Saving to: {0}' -f $SaveAs) -Verbose:$VerbosePreference
      $NewFile.SaveAs($SaveAs.FullName,[System.Text.UTF8Encoding]::new($false))
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
function Push-GitChanges {
  Param(
    [Parameter(Mandatory)]
    [ValidateScript({
          if (-not (Join-Path -Path $_ -ChildPath '.git' -Resolve)) {
            throw 'RepoPath must contain .git directory'
          }
          return $true
    })]
    [string]$RepoPath,
    [string]$Msg = (Get-Date).ToShortDateString()
  )
  Process{
    Invoke-InDirectory -Path $RepoPath -ScriptBlock {
      # Include - git pull command

      git add --all .
      git commit --all --message "$Msg"
      git push --all
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
Function Remove-EnvPath {
  param(
    [Parameter(Mandatory,ValueFromPipeline)]
    [ValidateScript({
          if (-not (Test-Path -Path $_ -PathType Container)) {
            throw 'Path must be a Folder'
          }
          if (-not ([System.IO.Path]::IsPathRooted($_))) {
            throw 'Path must be absolute, such as - C:\Program Files\Notepad++'
          }
          return $true
    })]
    [String[]]$Path,
    [System.EnvironmentVariableTarget]$VariableTarget = [System.EnvironmentVariableTarget]::Machine
  )
  begin {
    if (-not (Test-IfAdmin)) { throw 'RUN AS ADMINISTRATOR' }
    $OldPath = [System.Environment]::GetEnvironmentVariable('PATH',$VariableTarget).Split(';').TrimEnd('\') | Convert-Path -ErrorAction SilentlyContinue
    $NewPath = [System.Collections.ArrayList]::new()
    $NewPath.AddRange($OldPath)
  }
  process {
    foreach($RDir in $Path) {
      $RDir = (Convert-Path -Path $RDir -ErrorAction SilentlyContinue).TrimEnd('\')
      if ($NewPath -contains $RDir) { $NewPath.Remove($RDir) }
      else { Write-Warning -Message ('SKIPPING: {0} - was not found within - ({1}) PATH' -f $RDir,$VariableTarget) }
    }
  }
  end {
    [System.Environment]::SetEnvironmentVariable('PATH',(($NewPath | Sort-Object -Unique) -join ';'),$VariableTarget)
    $Confirm = [System.Environment]::GetEnvironmentVariable('PATH',$VariableTarget).Split(';')
    return $Confirm
  }
}
 
#.ExternalHelp woztools-Help.xml
Function Save-ISEFile {
  [CmdletBinding()]
  param(
    [ValidateScript({
          if ($_.Exists) {
          throw ('{1}{0} | Already Exists' -f $_.FullName,("`n"))
          }
          return $true
    })]
    [System.IO.FileInfo]$Path,
    [ValidateScript({
          if (-not ($psISE.CurrentPowerShellTab.Files[$_])) {
            throw '{2}Parameter must be between "{0}" - "{1}"' -f (0 - $psISE.CurrentPowerShellTab.Files.Count),($psISE.CurrentPowerShellTab.Files.Count - 1),("`n")
          }
          return $true
    })]
    [int]$i = -1,
    [switch]$ShowFile
  )
  $File = $psISE.CurrentPowerShellTab.Files[$i]
  if($ShowFile) { $File ; return }
  try {
    switch ($File.IsUntitled) {
      $true {
        if($Path) {
          if (-not (Split-Path -Path $Path -Parent | Test-Path)) {
            mkdir -Path (Split-Path -Path $Path -Parent)
          }
          $File.SaveAs($Path,[System.Text.UTF8Encoding]::new($false))
          break
        }
        else { throw ('{0}| -Path - Must be Set' -f $File.DisplayName) }
      }
      $false {
        $File.Save([System.Text.UTF8Encoding]::new($false))
        break
      }
    }
  }
  catch {
    [System.Management.Automation.ErrorRecord]$e = $_
    [PSCustomObject]@{
      Type      = $e.Exception.GetType().FullName
      Exception = $e.Exception.Message
      Reason    = $e.CategoryInfo.Reason
      Target    = $e.CategoryInfo.TargetName
      Script    = $e.InvocationInfo.ScriptName
      Line      = $e.InvocationInfo.ScriptLineNumber
      Column    = $e.InvocationInfo.OffsetInLine
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
function Search-WinCatalog {
  [CmdletBinding()]
  [Alias('dl-msu')]
  param(
    [Parameter(Mandatory)]
    [String]$KB,
    [ValidateSet('Windows 10','Server 2019')]
    [string]$OS = 'Windows 10'
  )
  $chrome = Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath 'Google\Chrome Beta\Application\chrome.exe' -Resolve
  switch ($OS) {
    'Windows 10' {
      $url = 'https://www.catalog.update.microsoft.com/Search.aspx?q=x64%20windows%2010%20{0}%20' -f $KB
      Start-Process -FilePath $chrome -ArgumentList $url
    }
    'Server 2019' {
      $url = 'https://www.catalog.update.microsoft.com/Search.aspx?q=x64%20server%202019%20{0}%20' -f $KB
      Start-Process -FilePath $chrome -ArgumentList $url
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
Function Select-GitHubLanguage {
  [CmdletBinding()]
  [Alias('GitLang')]
  param(
    [Parameter(Mandatory,ValueFromPipeline)]
    $InputObject,
    [string[]]$Languages = ('PowerShell','C#')
  )
  process{
    $InputObject | Where-Object {$_.language -match ($Languages -join '|')}
  }
}

 
#.ExternalHelp woztools-Help.xml
function Set-AutoLogin {
  [CmdletBinding(DefaultParameterSetName = 'Enable')]
  param(
    [Parameter(ParameterSetName = 'Enable')]
    [string]$User = $env:USERNAME,
    [Parameter(Mandatory,ParameterSetName = 'Enable',
    HelpMessage='Enter Password as a String')]
    [string]$Password,
    [Parameter(ParameterSetName = 'Enable')]
    [string]$Domain = $env:USERDOMAIN,
    [Parameter(ParameterSetName = 'Disable')]
    [switch]$Disable
  )
  begin{
    $RegPath = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon'
    if (-not (Test-Path -Path $RegPath)) {
      throw ('{0} - Path does not exsist' -f $RegPath)
    }
  }
  process{
    switch ($PSCmdlet.ParameterSetName){
      'Enable' {
          # autologon user domain password
          $url = 'https://live.sysinternals.com/Autologon.exe'
          $DLPath = [System.IO.Path]::Combine($env:TEMP,($url | Split-Path -Leaf))
          [System.Net.WebClient]::new().DownloadFile($url, $DLPath)

          Start-Process -FilePath $DLPath -ArgumentList ($User, $Domain, $Password) -NoNewWindow -Wait
        <#
        Set-ItemProperty -Path $RegPath -Name 'AutoAdminLogon' -Value 1 -Force -Verbose:$VerbosePreference
        Set-ItemProperty -Path $RegPath -Name 'DefaultDomainName' -Value $Domain -Force -Verbose:$VerbosePreference
        Set-ItemProperty -Path $RegPath -Name 'DefaultUserName' -Value $User -Force -Verbose:$VerbosePreference
        Set-ItemProperty -Path $RegPath -Name 'DefaultPassword' -Value $Password -Force -Verbose:$VerbosePreference
        #>
      }
      'Disable' {
        Set-ItemProperty -Path $RegPath -Name 'AutoAdminLogon' -Value 0 -Force -Verbose:$VerbosePreference
        Set-ItemProperty -Path $RegPath -Name 'DefaultPassword' -Value '' -Force -Verbose:$VerbosePreference
      }
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
function Set-ConsoleSize {
  [CmdletBinding()]
  [Alias('FixCon')]
  param(
    [int]$Width = 145,
    [int]$Height = 45
  )
  if ($env:WT_SESSION) {throw 'Does Not Work in Microsoft Terminal'}
  if ($Host.Name -notmatch 'ConsoleHost') {break}
  [console]::SetWindowSize($Width,$Height)
}
 
#.ExternalHelp woztools-Help.xml
function Set-ConsoleWindow {
  param(
    [Parameter(ParameterSetName='Hide')]
    [switch]$Hide,
    [Parameter(ParameterSetName='ShowNormal')]
    [switch]$ShowNormal,
    [Parameter(ParameterSetName='ShowMinimized')]
    [switch]$ShowMinimized,
    [Parameter(ParameterSetName='ShowMaximized')]
    [switch]$ShowMaximized,
    [Parameter(ParameterSetName='Maximize')]
    [switch]$Maximize,
    [Parameter(ParameterSetName='ShowNormalNoActivate')]
    [switch]$ShowNormalNoActivate,
    [Parameter(ParameterSetName='Show')]
    [switch]$Show,
    [Parameter(ParameterSetName='Minimize')]
    [switch]$Minimize,
    [Parameter(ParameterSetName='ShowMinNoActivate')]
    [switch]$ShowMinNoActivate,
    [Parameter(ParameterSetName='ShowNoActivate')]
    [switch]$ShowNoActivate,
    [Parameter(ParameterSetName='Restore')]
    [switch]$Restore,
    [Parameter(ParameterSetName='ShowDefault')]
    [switch]$ShowDefault,
    [Parameter(ParameterSetName='ForceMinimized')]
    [switch]$ForceMinimized
  )
  Begin {
    if (-not ('Console.Window' -as [type])) {
      # .Net methods for hiding/showing the console in the background
      Add-Type -Name Window -Namespace Console -MemberDefinition @'
        [DllImport("Kernel32.dll")]
        public static extern IntPtr GetConsoleWindow();

        [DllImport("user32.dll")]
        public static extern bool ShowWindow(IntPtr hWnd, Int32 nCmdShow);
'@
    }
  }
  Process {
    $sval = switch($PsCmdlet.ParameterSetName) {
      'Hide' {'0'}
      'ShowNormal' {'1'}
      'ShowMinimized' {'2'}
      'ShowMaximized' {'3'}
      'Maximize' {'3'}
      'ShowNormalNoActivate' {'4'}
      'Show' {'5'}
      'Minimize' {'6'}
      'ShowMinNoActivate' {'7'}
      'ShowNoActivate' {'8'}
      'Restore' {'9'}
      'ShowDefault' {'10'}
      'ForceMinimized' {'11'}
      'Default' {throw 'Error has occured while assigning numerial values'}
    }
    $null = [Console.Window]::ShowWindow([Console.Window]::GetConsoleWindow(), $sval)
  }
}
 
#.ExternalHelp woztools-Help.xml
function Set-MaxPartitionSize {
  [CmdletBinding()]
  [Alias('Max-PartitionSize')]
  param()
  dynamicparam {
    $ParamName = 'DriveLetter'
    [String[]]$Values = (Get-CimInstance -ClassName Win32_Volume | Select-Object -ExpandProperty DriveLetter | Sort-Object).Replace(':', '')

    $Bucket = [System.Management.Automation.RuntimeDefinedParameterDictionary]::new()
    $AttributeList = [System.Collections.ObjectModel.Collection[System.Attribute]]::new()
    $AttribValidateSet = [ValidateSet]::new($Values)
    $AttributeList.Add($AttribValidateSet)
    $AttribParameter = [Parameter]::new()
    $AttribParameter.Mandatory = $true
    $AttributeList.Add($AttribParameter)
    $Parameter = [System.Management.Automation.RuntimeDefinedParameter]::new($ParamName, [String], $AttributeList)
    $Bucket.Add($ParamName, $Parameter)
    $Bucket
  }
  process{
    $Letter = $PSBoundParameters[$ParamName]

    $Size = (Get-PartitionSupportedSize -DriveLetter $Letter).SizeMax
    Resize-Partition -DriveLetter $Letter -Size $Size -Verbose:$VerbosePreference
    Get-Volume -DriveLetter $Letter
  }
}
 
#.ExternalHelp woztools-Help.xml
Function Start-ConsoleCommand {
  [CmdletBinding()]
  [Alias('scc')]
  Param(
    [AllowNull()]
    [scriptblock]$ConsoleCommand,
    [switch]$Admin
  )
  if($Admin) {
  Start-Process -FilePath powershell -ArgumentList ('-NoExit -Command {0}' -f $ConsoleCommand) -Verb RunAs
  }
  else {
    Start-Process -FilePath powershell -ArgumentList ('-NoExit -Command {0}' -f $ConsoleCommand)
  }
}
 
#.ExternalHelp woztools-Help.xml
function Start-PSLogging {
  [CmdletBinding(DefaultParameterSetName = 'Default')]
  param(
    [ValidateScript({
          if (-not ($_ | Test-Path -PathType Leaf -IsValid)) {
            throw 'Invalid Path.  Path must be a file.'
          }
          return $true
    })]
    [Parameter(ParameterSetName = 'Path')]
    [string]$Path,
    [Parameter(ParameterSetName = 'Default')]
    [switch]$Default
  )
  $PSLogPath = switch ($PSCmdlet.ParameterSetName) {
    'Path' {
      $Path
    }
    default {
      [System.IO.Path]::Combine(
        ($PROFILE | Split-Path -Parent),
        'logs',
        [datetime]::Today.ToString('MMM'),
        [datetime]::Today.Day,
        ('{0}-{1}.log' -f (Get-Process -Id $PID).ProcessName,$PID)
      )
    }
  }
  $null = Import-Module -Global PSReadline -MinimumVersion 2.2.2 -ErrorAction Stop
  
  try {
    Set-PSReadLineOption -PredictionSource HistoryAndPlugin
    Import-Module -Global Az.Tools.Predictor -PassThru:$false
  }
  catch {
    Set-PSReadLineOption -PredictionSource History
  }
  'PredictionSource: {0}' -f (Get-PSReadLineOption).PredictionSource | Write-Verbose

  Set-PSReadLineOption -ShowToolTips
  Set-PSReadLineOption -HistorySaveStyle SaveIncrementally
  Set-PSReadLineOption -HistorySavePath $PSLogPath
  'HistorySavePath: {0}' -f (Get-PSReadLineOption).HistorySavePath | Write-Verbose
  $Test = Test-Path -Path $PSLogPath
  if (-not ($Test)) {
    $null = New-Item -Path $PSLogPath -ItemType File -Force
  }
}
 
#.ExternalHelp woztools-Help.xml
Function Test-IfAdmin {
    ([System.Security.Principal.WindowsPrincipal][System.Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)
}
 filter Test-Url {
[CmdletBinding(PositionalBinding)]
  param (
    [Parameter(Mandatory,ValueFromPipeline)]
    [String[]]$Url,
	  [System.UriKind]$UriKind = [System.UriKind]::Absolute
  )
  Process {
    foreach($U in $Url) {
      if ([System.Uri]::IsWellFormedUriString($U, $UriKind)) {
        $true
      }
      else {
        $false
      }
    }
  }
}
 
#.ExternalHelp woztools-Help.xml
function Write-MyProgress {
  <#
      .SYNOPSIS
      Displays a progress bar within a Windows PowerShell command window.

      .DESCRIPTION
      The Write-Progress cmdlet displays a progress bar in a Windows PowerShell command window that depicts the status of a running command or script.

      .NOTES
      File Name   : Write-MyProgress.ps1
      Author      : Woz
      Date        : 2017-05-10
      Last Update : 2023-01-14
      Version     : 2.0.0

      .PARAMETER id
      Specifies an ID that distinguishes each progress bar from the others.

      .PARAMETER ParentId
      Specifies the parent activity of the current activity.

      .PARAMETER StartTime
      StartTime of the foreach processing

      .PARAMETER Object
      Object use in your foreach processing

      .PARAMETER Count
      Foreach Count variable

      .EXAMPLE
      $GetProcess = Get-Process

      $Count = 0
      $StartTime = Get-Date
      foreach($Process in $GetProcess) {
      $Count++
      Write-MyProgress -StartTime $StartTime -Object $GetProcess -Count $Count

      Write-Host "-> $($Process.ProcessName)"
      Start-Sleep -Seconds 1
      }

      .LINK

      Source
      https://github.com/Netboot-France/Write-MyProgress
  #>
  Param(
    [CmdletBinding()]
    [Parameter(Mandatory)]
    [Array]$Object,
    [Parameter(Mandatory)]
    [DateTime]$StartTime,
    [Parameter(Mandatory)]
    [Int]$Count,
    [Int]$Id = $null,
    [Int]$ParentId = -1
  )
  $SecondsElapsed = ((Get-Date) - $StartTime).TotalSeconds
  $SecondsRemaining = ($SecondsElapsed / ($Count / $Object.Count)) - $SecondsElapsed
  $PercentComplete = ($Count/($Object.Count)) * 100

  $Argument = @{}
  $Argument.Add('Activity', ('Processing {0} of {1}' -f $Count, $Object.Count))
  $Argument.Add('PercentComplete', $PercentComplete)
  $Argument.Add('CurrentOperation', ('{0:N2}% Complete' -f $PercentComplete))
  $Argument.Add('SecondsRemaining', $SecondsRemaining)

  if($Id -ne $null) { $Argument.Add('Id', $Id) }
  if($ParentId -ne $null) { $Argument.Add('ParentId', $ParentId) }

  Write-Progress @Argument
}
